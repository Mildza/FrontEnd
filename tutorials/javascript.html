<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>

    <link rel="stylesheet" type="text/css" href="../sass/style.css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
    <title>JavaScript</title>

    <style media="screen">

    p {margin:0; padding:0; text-align: justify;}
    #dimensions {cursor: pointer;}

    </style>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>
    function dim(){
        var pattern = prompt("Enter ellement", "for classes=.class  for id=#div or for tag=a");
        if (pattern != null) {
        var txt = "";
        txt += "Width: " + $(pattern).width() + "\n";
        txt += "Height: " + $(pattern).height() + "\n";
        txt += "Padding(left+right): " + ($(pattern).innerWidth()-$(pattern).width()) + "\n";
        txt += "Padding(up+down): " + ($(pattern).innerHeight()-$(pattern).height()) + "\n";
        txt += "Border: " + ($(pattern).outerWidth()-$(pattern).innerWidth())/2 + "\n";
        txt += "Margin(left+right): " + ($(pattern).outerWidth(true)-$(pattern).outerWidth()) + "\n";
        txt += "Margin(up+down): " + ($(pattern).outerHeight(true)-$(pattern).outerHeight()) + "\n";
        txt += "Windows size: " + $(document).width();
        txt += "x" + $(document).height() + "\n";
        txt += "Viewport size: " + $(window).width();
        txt += "x" + $(window).height() + "\n";
        txt += "Scroll height" + window.pageYOffset ;
       alert(txt);
     }
};
    </script>
    </head>


  <body>
    <div class="wrapper-tuts">
    <a href="top:" id="return-to-top"></a>
    <a class="home-picture" href="../index.html"><img src="../images/home.png" alt="Home"></a>
  <h1>JavaScript</h1>
  <script type="text/javascript">

  </script>
  <h3>Syntax Parsers</h3>
  <p>Read our code and determines what is valid and what we trying to do, character by charcter.</p>

  <h3>Whitespace - carriage returns, tabs, spaces.</h3>
  <p>Syntax parser just ignore white spaces</p>
  <p>JS is very liberal about whitespace.</p>

  <h3>Automatic Semicolon Insertion</h3>
  <p>JS engine put semicolon where is missing.</p>
  <p>Always put curly bracket at same line as function, foor loop, if statement.</p>

  <h3>Syntactic sugar</h3>
  <p> A different way to type something that doesnt change how it works under the hood.</p>

  <h3>Polyfill</h3>
  <p>Code that adds a feature which the engine may lack.</p>

  <h3>Execution Context</h3>
  <p>A wrapper to help manage the code that is running.</p>
  <p>Global execution context creates Global objects (window) and special variable "this".</p>
  <p>Global means that is not inside a function.</p>
  <p>Functions and variables are sitting in global window object.</p>
  <p>Functions can be called before they are declared.</p>
  <p>Always declare all variables at the beginning of every scope.</p>
  <p>JavaScript in strict mode, "use strict", does not allow variables to be used if they are not declared. It must be on the top of the code or at the top of the function.</p>
<p>Single Threaded - one command at a time.</p>
<p>Synchronous - one line of at a time in order that apears.</p>
<p>Invocation - runnig a function, using parenthesis ()</p>
<p>Every function creates new execution context at the top of the stack.</p>
<p>Scope - Where a variable is available in your code, block scoping.</p>
<p>Let - Declare and available inside block.</p>
<p>Asynchronous - more than one at a time, like Browser handle request.</p>

<h3>Event Queue - full of events</h3>
<p>Only when stack is empty engine look periodicly at event queue, wait to something be there. Like Click, HTTP request.</p>

<h3>Dynamic Typing</h3>
<p>We dont tell the engine what type of data a variable holds, it figures it out while our code is running. Variables can hold different types of values because its all figured out during execution.</p>

<h3>Namespace</h3>
<p>A container for variable and functions, typically to keep variables and functions with the same name separate.</p>

<h3>Faking Namespace</h3>
<p>To avoid conflict in namespace we can use object as name container</p>
<pre><code>var english = {}
var spanish = {}
english.greet = "Hello";
spanish.greet = "Hola!";
console.log(english.greet);</code></pre>

<h3>6 Primitive types</h3>
<p>Primitive type - a type of data that represents a single value, not a object.</p>
<p>1. Undefined - representts lack of existence (we shouldnt set a variable to this)</p>
<p>2. Null - representts lack of existence (we can set a variable to this)</p>
<p>3. Boolean - true or false </p>
<p>4. Number -Floating point number (there's always some decimals).</p>
<p>5. String - A sequence of characters (both '' and "" can be used).</p>
<p>6. Symbol (ES6) - </p>
<h3>Variables by Value and by Reference</h3>
<p>By Value</p>
<pre><code>a = primitive value
b = a
b = copy of primitive value
b have new address
2 separets spots in memory</code></pre>
<pre><code>var a =3;
b = a;
a = 2;
console.log(a); // 2
console.log(b); // 3</code></pre>
<p>By Reference</p>
<pre><code>When set up variable equal to object
b = a
or
pass to a function
simple point to the same location in a memory like a, 2 name to the same address</code></pre>
<p>All objects interact by reference when sending them equals to each other or passing to a function</p>
<pre><code>var c = { greetings: 'hi' };
var d;
d = c;
c.greeting = 'Hello';
console.log(c); // Hello
console.log(d); // Hello

// even as parameters

function changeGreeting (obj) {
  obj.greeting = 'Hola';
}
console.log(c); // Hola
console.log(d); // Hola

// equals operator sets up new memory space (new address)

c = { greeting: 'Howdy'}; // new objects

console.log(c); // Howdy
console.log(d); // Hola</code></pre>
<h3>Operators</h3>
<p>Generally, take two parameters and return one result. Operators are functions.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">Operator Precedence</a> - which operator function gets called first. Functions are called in order of precedence. Higher precedece wins.</p>
<p>Associativity - what order operator functions get called in: left to right or right to left. When functions have the same precednce.</p>
<h3>Coercion</h3>
<p>Converting a value from one type to another.</p>
<p>Example of coercion to check if something exists:</p>
<pre><code>if (a) {
    console.log("Something is there.")

}</code></pre>
<p>Always use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness">Strict Equality Comparison</a> ===</p>
<p>Example of set default values in the case of no values is passingS:</p>
<pre><code>function greet(name) {
    name = name || "Your name here";
    console.log("Hello " + name);
}greet();</code></pre>

<h3>Name/Value pair</h3>
<p>A name which maps to unique value.</p>
<p>The name may be defined more than once, but only can have one value in any given context.That value may be more name/value pairs.</p>
<pre><code>Address = "21 Jump Street"</code></pre>

<h3>Object</h3>
<p>Creating Objects - There are the two common ways to create objects:</p>
<p>Object Constructor</p>
<pre><code>var person = new Object();
person.name = "John";
person.lastname = "Doe";</code></pre>
<p>Object Literals - the easiest way</p>
<pre><code>var person = {
  name: "John",
  lastname: "Doe"
 };//shorthand objects literal</code></pre>
<p>A collection of name value pairs, separated by coma ",".</p>
<p>Object can contains: Primitive - property, Object - property, Function - method.</p>
<pre><code>Addres: {
    street: "Jump Street",
    Number: "21",
    Appartment: {
      Floor: 3,
      Number: 301
    }
  }</code></pre>
<p>Computed and dot (always use dot) notation to find properties:</p>
<pre><code>person["firstname"] = "John";
person.firstname = "John";</code></pre>
<p>Objects properties and methods</p>
<pre><code>var object = {
    greet: "hello"
}

console.log(object.greet)
console.log(object['greet'])

var prop = "greet"

console.log(object[prop])</code></pre>
<p>Constructor Pattern for Creating Objects</p>
<pre><code>function Greet(firstName, lastName) {
  this.firstname = firstName;
  this.lastname = lastName;

  this.fullname = function(firstname, lastname) {
      console.log(firstname + " " + lastname);
  }
}
var greeting = new Greet;
greeting.fullname("John", "Doe");</code></pre>
<p>Objects have inherited properties and own properties. The own properties are properties that were defined on the object, while the inherited properties were inherited from the object’s Prototype object.</p>
<pre><code>var person = {firstname:"John"};
console.log(person.hasOwnProperty("firstname")) // true;</code></pre>
<p>To access the enumerable (own and inherited) properties on objects, you use the for/in loop or a general for loop.
</p>
<pre><code>var person = {firstname:"John", lastname:"Doe", gender:"male"};
for (var eachItem in person) {
console.log(eachItem); // firstname lastname gender
}</code></pre>
<p>Deleting Properties of an Object  -
To delete a property from an object, you use the delete operator. You cannot delete properties that were inherited, nor can you delete properties with their attributes set to configurable. You must delete the inherited properties on the prototype object (where the properties were defined). Also, you cannot delete properties of the global object, which were declared with the var keyword.</p>
<pre><code>var person = {firstname:"John", lastname:"Doe", gender:"male"};
delete person.firstname;</code></pre>
<h3>Serialize and Deserialize Objects</h3>
<p>To transfer your objects via HTTP or to otherwise convert it to a string, you will need to serialize it (convert it to a string); you can use the JSON.stringify function to serialize your objects.</p>
<pre><code>var person = {firstname:"John",lastname:"Doe",gender:"male"};
var person2 = JSON.stringify(person, null,2);</code></pre>
<p>To Deserialize your object (convert it to an object from a string), you use the JSON.parse function </p>
<pre><code>var js = '{"firstname":"John","lastname":"Doe","gender":"male"}';
var jsObj = JSON.parse(js);</code></pre>

<h3>First Class Functions</h3>
<p>Everything we can do with other types we can do with functions. Assign them to variables, pass them around, create them on the fly.</p>
<p>We can attach primitive, object, function, name (can be anonymous), code which we can be invocable ().</p>
<p>Functions are special type of object.</p>
<h3>Function Statements and Function Expressions</h3>
<p>Statements just do work, not return a value like if statement</p>
<pre><code>function greet() {
  console.log("hi");
}
greet();</code></pre>
<p>Expression - a unit of code that result in a value, it doesnt have to save to a variable.</p>
<p>Function Expression is hoisted. Its not initialy in memory, its create on the fly.</p>
<pre><code>var anonymousGreet = function() {
  console.log("hi");
}
anonymousGreet();</code></pre>
<p>Functions expression passing function as parameter</p>
<pre><code>function log(a) {
  a();
}
log(function(){
  console.log("Hi");
});</code></pre>
<p>Use a functions expression on the fly</p>
<pre><code>logGreeting(function(){
  console.log("Hi");
});</code></pre>
<p>Functions and arrays</p>
<pre><code>var arr = []

arr.push(function(){
    console.log("Hello 1")
})
arr.push(function(){
    console.log("Hello 2")
})
arr.push(function(){
    console.log("Hello 3")
})
arr.forEach(function(item, index){
    item()
})</code></pre>
<h3>Immediately Invoked Function Expressions - (IIFE)S</h3>
<p>Run the function at point is created.</p>
<pre><code>
var greeting = function(name) {
  return 'Hello ' + name;
}('John');</code></pre>
<p>Creat own excution context.</p>
<pre><code>// IIFE
var firstname = 'John';

(function(name) {
  var greeting = 'Inside IIFE: Hello';
  console.log(greeting + ' ' + name);
}(firstname)); // IIFE</code></pre>

<h3>Closures - feature of JavaScript</h3>
<p>Every function we running it wiil have access to variables that suppose to have access. </p>
<p>When invoke the function engine look for variables to outer environment - to place of creation.</p>
<p>Its represent value of now not at the time when function is executed.</p>
<p>free variables - still has access to outter variables </p>
 <pre><code>function greet(whattosay) {
  return function(name) {
  console.log(whattosay + ' '  + name);
  }
}
greet("Hola")('Milan'); // Hola Milan
// closures
var sayHi = greet('Hi');
sayHi('Tony'); //Hi Tony</code></pre>
<pre><code>function buildFunctions() {
  var arr = [];
  for (var i = 0; i < 3; i++) {
    arr.push(
      function() {
        console.log(i);
      }
    )
  }
  return arr;
}
var fs = buildFunctions();
fs[0](); // 3
fs[1](); // 3
fs[2](); // 3</code></pre>
<pre><code>function buildFunctions2() {
  var arr = [];
  for (var i = 0; i < 3; i++) {
    arr.push(
      (function(j) {
        return function() {
          console.log(j);
        }
      }(i))
    )
  }
  return arr;
}
var fs2 = buildFunctions2();
fs2[0](); // 0
fs2[1](); // 1
fs2[2](); // 2</code></pre>

<h3>Function Factory</h3>
<p>Factory  - functions that mix or returns something for us</p>
<p>Every time when we call a function makes new execution context.</p>
<pre><code>function makeGreeting(language) {
  return function(firstname, lastname) {
    if (language === 'en') {
      console.log('Hello ' + firstname + ' ' + lastname);
    }
    if (language === 'es') {
      console.log('Hola ' + firstname + ' ' + lastname);
    }
  }
}
var greetEnglish = makeGreeting('en');
var greetSpanish = makeGreeting('es');

greetEnglish('John', 'Doe'); // Hello John Doe
greetSpanish('John', 'Doe'); // Hola John Doe</code></pre>
<h3>Closure and Callback</h3>
<p>Callback - Function you give to another function, to be run when the other function is finished.</p>
<p>A function passed to some other function which we assume vill be invoked at the some point. Tfu functions 'calls back', invoking the function you give it when it is done doing its work.</p>
<pre><code>function sayHiLater() {
  var greeting = 'Hi!';
  setTimeout(function() {
    console.log(greeting);
  }, 3000);
}
sayHiLater();

// jQuery uses function expressions and first-class functions!
//$("button").click(function() {
//
//});
function tellMeWhenDone(callback) {
  var a = 1000; // some work
  var b = 2000; // some work
  callback(); // the 'callback', it runs the function I give it!
}
tellMeWhenDone(function() {
  console.log('I am done!');
});
tellMeWhenDone(function() {
  console.log('All done...');
});</code></pre>
<pre><code>function greet(callback) {
  console.log('hello')
  var data = {
      name: "John"
  }
  callback(data)
}

greet(function(data) {
    console.log('Somebody call me')
    console.log(data.name)
})</code></pre>
<h3>This</h3>
<p>Inside function this point to global, window object.</p>
<p>Inside object this point to object, even if function inside object beacuse function inside object is a method.</p>
<p>But this inside fuction who sits inside function point to global, window.</p>
<p>To avoid problem best way to declare varaible self to point to this object.</p>
<pre><code>var c = {
  name: 'The c object',
  log: function() {
    var self = this;
    self.name = 'Updated c object';
    console.log(self);
    var setname = function(newname) {
      self.name = newname;
    }
    setname('Updated again! The c object');
    console.log(self);
  }
}
c.log();</code></pre>
<h3>Arguments - ES6 Spread</h3>
<p>Arguments contains a list of all values, parameters we passed to function.</p>
<p>keyword arguments - containig a list of all values passed to function</p>
<pre><code>function greet(firstname, lastname, language) {
 language = language || 'en';
 if (arguments.length === 0) {
    console.log('Missing parameters!');
    console.log('-------------');
    return;
  }
  console.log(firstname);
  console.log(lastname);
  console.log(language);
  console.log(arguments);
  console.log('arg 0: ' + arguments[0]);
  console.log('-------------');
}
greet();
greet('John');
greet('John', 'Doe');
greet('John', 'Doe', 'es');

// in ES6 I can do:  function greet(firstname, ...other)
// and 'other' will be an array that contains the rest of the arguments</code></pre>
<h3>call(), apply() and bind()</h3>
<p>All functions have access to this 3 methods.</p>
<p>bind - returns new functions, makes a copy of function and whatever method, object passed by. </p>
<p>call execute functions, not create a copy</p>
<p>apply passed parameters as array</p>

<pre><code>var person = {
  firstname: 'John',
  lastname: 'Doe',
  getFullName: function() {
    var fullname = this.firstname + ' ' + this.lastname;
    return fullname;
  }
}
var logName = function(lang1, lang2) {
  console.log('Logged: ' + this.getFullName());
  console.log('Arguments: ' + lang1 + ' ' + lang2);
  console.log('-----------');
}
var logPersonName = logName.bind(person);
logPersonName('en');

logName.call(person, 'en', 'es');
logName.apply(person, ['en', 'es']);

(function(lang1, lang2) {
  console.log('Logged: ' + this.getFullName());
  console.log('Arguments: ' + lang1 + ' ' + lang2);
  console.log('-----------');
}).apply(person, ['es', 'en']);

// function borrowing
var person2 = {
  firstname: 'Jane',
  lastname: 'Doe'
}
console.log(person.getFullName.apply(person2));
// function currying
function multiply(a, b) {
  return a*b;
}
var multipleByTwo = multiply.bind(this, 2);
console.log(multipleByTwo(4));</code></pre>
<p>Function Currying - Creating a copy of a function but with some preset parameters.</p>
<h3>Functional programming</h3>
<pre><code>function mapForEach(arr, fn) {
  var newArr = [];
  for (var i=0; i < arr.length; i++) {
    newArr.push(
      fn(arr[i])
      )
  };
  return newArr;
}

var arr1 = [1,2,3];
console.log(arr1);

var arr2 = mapForEach(arr1, function(item) {
 return item * 2;
});
console.log(arr2);

var arr3 = mapForEach(arr1, function(item) {
 return item > 2;
});
console.log(arr3);

var checkPastLimit = function(limiter, item) {
  return item > limiter;
}
var arr4 = mapForEach(arr1, checkPastLimit.bind(this, 1));
console.log(arr4);

var checkPastLimitSimplified = function(limiter) {
  return function(limiter, item) {
    return item > limiter;
  }.bind(this, limiter);
};

var arr5 = mapForEach(arr1, checkPastLimitSimplified(1));
console.log(arr5);</code></pre>

<h3>Function as Function Constructor</h3>
<p>Function constructors - a normal function that is used to construct object.  This variable points a new empty object, and that object is returned from the the function automaticaly.</p>
<h3>Prototype</h3>
<p>Every JavaScript function has a prototype property (this property is empty by default), and you attach properties and methods on this prototype property when you want to implement inheritance.</p>
<p>This prototype property is not enumerable; that is, it isn’t accessible in a for/in loop. </p>
<p>The prototype property is used primarily for inheritance, you add methods and properties on a function’s prototype property to make those methods and properties available to instances of that function.</p>
<p>Use <strong>new</strong> as function constructor.</p>
<p>Prototype - used only by the new operator.</p>
<p>Always use capitol letter in the name of function if we will use as function constructor.</p>
<p>Properties are in the functions constructors and methods are sitting in prototype.</p>
<p>Method is placeing outside the function to reduce memory space in the case we have a plenty instances of functions.</p>
<p>It will be changed in ECMAScript 6.</p>
<pre><code>function Person(firstname, lastname) {
  this.firstname = firstname;
  this.lastname = lastname;
}
var john = new Person("John", "Doe");
var jane = new Person("Jane", "Doe");

console.log(jane.firstname + ' ' + jane.lastname);

Person.prototype.getformalname = function() {
  return this.lastname + ', ' + this.firstname;
}
console.log(john.getformalname());</code> </pre>
<h3>Prototype Property: Prototype-based Inheritance</h3>
 <p>Prototype is important in JavaScript because JavaScript does not have classical inheritance based on Classes (as most object oriented languages do), and therefore all inheritance in JavaScript is made possible through the prototype property. JavaScript has a prototype-based inheritance mechanism.Inheritance is a programming paradigm where objects (or Classes in some languages) can inherit properties and methods from other objects (or Classes). In JavaScript, you implement inheritance with the prototype property</p>

<h3>Prototype Attribute: Accessing Properties on Objects</h3>
<p>If you want to access a property of an object, the search for the property begins directly on the object. If the JS runtime can’t find the property there, it then looks for the property on the object’s prototype—the object it inherited its properties from.
If the property is not found on the object’s prototype, the search for the property then moves to prototype of the object’s prototype (the father of the object’s father—the grandfather). </p>


 <h3>Reflection</h3>
 <p>AN object can look at itself, listening and changing its properties and methods.</p>


<h3>Pure Prototypal Inheritance - Object.create</h3>
<pre><code>// polyfill ////////
if (!Object.create) {
  Object.create = function (o) {
    if (arguments.length > 1) {
      throw new Error('Object.create implementation'
      + ' only accepts the first parameter.');
    }
    function F() {}
    F.prototype = o;
    return new F();
  };
}
/////////////////
var person = {
  firstname: 'Default',
  lastname: 'Default',
  greet: function() {
      return 'Hi ' + this.firstname;
  }
}

var john = Object.create(person);
john.firstname = 'John';
john.lastname = 'Doe';
console.log(john);</code></pre>


<h3>Arrays - Collections of Anything</h3>
<p>Each individual item in array can be differnet type.</p>
<pre><code>var arr = [
  1,
  false,
  {
    name: "Milan",
    addres: "VPD 11"
  },
  fuction(name) {
    var greeting = "Hello ";
    console.log(greeting + name);
  },
  "Hello"
];
// run a fuction with name parameter
arr[3](arr[2].name);</code></pre>
  <h3>Method Chaining </h3>
  <p>Calling one method after another, and each method affects the parent object.</p>
  <pre><code>var q = $("ul.people").addClass("newclass").removeClass("people");</code></pre>
<h4>Dont use "for in" un arrays.</h4>



  <h3>Dimensions</h3>
  <p>Get width, height, padding, margin, border, window size, viewport and scroll height.</p>
  <pre id="dimensions" onclick="dim()"><code>$(document).ready(function(){
  var pattern = prompt("Enter ellement", "for classes=.class  for id=#div or for tag=a");
  if (pattern != null) {
    var txt = "";
    txt += "Width: " + $(pattern).width() + "\n";
    txt += "Height: " + $(pattern).height() + "\n";
    txt += "Padding(left+right): " + ($(pattern).innerWidth()-$(pattern).width()) + "\n";
    txt += "Padding(up+down): " + ($(pattern).innerHeight()-$(pattern).height()) + "\n";
    txt += "Border: " + ($(pattern).outerWidth()-$(pattern).innerWidth())/2 + "\n";
    txt += "Margin(left+right): " + ($(pattern).outerWidth(true)-$(pattern).outerWidth()) + "\n";
    txt += "Margin(up+down): " + ($(pattern).outerHeight(true)-$(pattern).outerHeight()) + "\n";
    txt += "Windows size: " + $(document).width();
    txt += "x" + $(document).height() + "\n";
    txt += "Viewport size: " + $(window).width();
    txt += "x" + $(window).height() + "\n";
    txt += "Scroll height" + window.pageYOffset ;
    alert(txt);
  }
});</code></pre>

<br>
    <div class="footer-tuts">
    | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">Reference</a>
    | <a href="https://github.com/lukehoban/es6features">ECMA6 Features</a>
    | <a href="https://www.youtube.com/watch?v=Bv_5Zv5c-Ts" target="_blank"><img class="icons" src="../images/youtube.png" alt="youtube" /></a>
    | <a href="http://underscorejs.org/">Underscore.js</a>
    | <a href="http://momentjs.com/">Moment.js</a> |

  </div>

</div>
  </body>
  <script src="../js/scroll.js"></script>
</html>
