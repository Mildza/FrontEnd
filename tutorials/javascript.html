<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="../stylesheets/style.css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
    <title>JavaScript</title>

    <style media="screen">

    p {margin:0; padding:0; text-align: justify;}
    #dimensions {cursor: pointer;}

    </style>
    <script src="../js/highlighter2.js"></script>
    <script>
    function dim(){
        var pattern = prompt("Enter ellement", "for classes=.class  for id=#div or for tag=a");
        if (pattern != null) {
        var txt = "";
        txt += "Width: " + $(pattern).width() + "\n";
        txt += "Height: " + $(pattern).height() + "\n";
        txt += "Padding(left+right): " + ($(pattern).innerWidth()-$(pattern).width()) + "\n";
        txt += "Padding(up+down): " + ($(pattern).innerHeight()-$(pattern).height()) + "\n";
        txt += "Border: " + ($(pattern).outerWidth()-$(pattern).innerWidth())/2 + "\n";
        txt += "Margin(left+right): " + ($(pattern).outerWidth(true)-$(pattern).outerWidth()) + "\n";
        txt += "Margin(up+down): " + ($(pattern).outerHeight(true)-$(pattern).outerHeight()) + "\n";
        txt += "Windows size: " + $(document).width();
        txt += "x" + $(document).height() + "\n";
        txt += "Viewport size: " + $(window).width();
        txt += "x" + $(window).height() + "\n";
        txt += "Scroll height" + window.pageYOffset ;
       alert(txt);
     }
};
    </script>
    </head>


  <body>
    <div class="wrapper-tuts">
    <a href="top:" id="return-to-top"></a>
    <a class="home-picture" href="../index.html"><img src="../images/home.png" alt="Home"></a>
  <h1>JavaScript</h1>
  <script type="text/javascript">

  </script>
  <h3>Execution Context</h3>
  <p>A wrapper to help manage the code that is running.</p>
  <p>Global execution context creates Global objects (window) and special variable "this".</p>
  <p>Global means that is not inside a function.</p>
  <p>Functions and variables are sitting in global window object.</p>
  <p>Functions can be called before they are declared.</p>
  <p>Always declare all variables at the beginning of every scope.</p>
  <p>JavaScript in strict mode, "use strict", does not allow variables to be used if they are not declared. It must be on the top of the code or at the top of the function.</p>
<p>Single Threaded - one command at a time.</p>
<p>Synchronous - one line of at a time in order that apears.</p>
<p>Invocation - runnig a function, using parenthesis ()</p>
<p>Every function creates new execution context at the top of the stack.</p>
<p>Scope - Where a variable is available in your code, block scoping.</p>
<p>Let - Declare and available inside block.</p>
<p>Asynchronous - more than one ta a time, like Browser handle request.</p>
<h3>Event Queue - full of events</h3>
<p>Only when stack is empty engine look periodicly at event queue, wait to something be there. Like Click, HTTP request.</p>
<h3>Dynamic Typing</h3>
<p>We dont tell the engine what type of data a variable holds, it figures it out while our code is running. Variables can hold different types of values because its all figured out during execution.</p>
<h3>Namecpace</h3>
<p>A container for variable and functions, typically to keep variables and functions with the same name separate.</p>
<h3>6 Primitive types</h3>
<p>Primitive type - a type of data that represents a single value, not a object.</p>
<p>1. Undefined - representts lack of existence (we shouldnt set a variable to this)</p>
<p>2. Null - representts lack of existence (we can set a variable to this)</p>
<p>3. Boolean - true or false </p>
<p>4. Number -Floating point number (there's always some decimals).</p>
<p>5. String - A sequence of characters (both '' and "" can be used).</p>
<p>6. Symbol (ES6) - </p>
<h3>Operators</h3>
<p>Generally, take two parameters and return one result. Operators are functions.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">Operator Precedence</a> - which operator function gets called first. Functions are called in order of precedence. Higher precedece wins.</p>
<p>Associativity - what order operator functions get called in: left to right or right to left. When functions have the same precednce.</p>
<h3>Coercion</h3>
<p>Converting a value from one type to another.</p>
<p>Example of coercion to check if something exists:</p>
<pre>
if (a) {
    console.log("Something is there.")

}</pre>
<p>Always use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness">Strict Equality Comparison</a> ===</p>
<p>Example of set default values in the case of no values is passingS:</p>
<pre>function greet(name) {
    name = name || "Your name here";
    console.log("Hello " + name);
}greet();</pre>
  <h3>Name/Value pair</h3>
  <p>A name which maps to unique value.</p>
  <p>The name may be defined more than once, but only can have one value in any given context.That value may be more name/value pairs.</p>
  <pre>Address = "21 Jump Street"</pre>
  <h3>Object</h3>
  <p>Create object</p>
  <pre>
  var person = new Object();
  var person = { };//shorthand objects literal
  </pre>
  <p>A collection of name value pairs, separated by coma ",".</p>
  <p>Object can contains: Primitive - property, Object - property, Function - method.</p>
  <pre>
Addres:
    {
        street: "Jump Street",
        Number: "21",
        Appartment: {
            Floor: 3,
            Number: 301
        }
    }</pre>
<p>Computed and dot (always use dot) notation to find properties:</p>
<pre>
person["firstname"] = "Milan";
person.firstname = "Milan";</pre>

<h3>Faking Namespace</h3>
<p>To avoid conflict in namespace we can use object as name container</p>
<pre>
var english = {}
var spanish = {}
english.greet = "Hello";
spanish.greet = "Hola!";
console.log(english.greet);</pre>

<h3>First Class Functions</h3>
<p>Everything we can do with other types we can do with functions. Assign them to variables, pass them around, create them on the fly.</p>
<p>We can attach primitive, object, function, name (can be anonymous), code which we can be invocable ().</p>
<p>Functions are special type of object.</p>
<h3>Function Statements and Function Expressions</h3>
<p>Statements just do work, not return a value like if statement</p>
<pre>function greet() {
  console.log("hi");
}
greet();</pre>
<p>Expression - a unit of code that result in a value, it doesnt have to save to a variable.</p>
<p>Function Expression is hoisted. Its not initialy in memory, its create on the fly.</p>
<pre>var anonymousGreet = function() {
  console.log("hi");
}
anonymousGreet();</pre>
<p>Functions expression passing function as parameter</p>
<pre>function log(a) {
  a();
}
log(function(){
  console.log("Hi");
});</pre>
<h3>Immediately Invoked Function Expressions - (IIFE)S</h3>
<p>Run the function at point is created.</p>
<pre>
var greeting = function(name) {
    return 'Hello ' + name;
}('John');
</pre>
<p>Creat own excution context.</p>
<pre>
// IIFE
var firstname = 'John';

(function(name) {

  var greeting = 'Inside IIFE: Hello';
  console.log(greeting + ' ' + name);

}(firstname)); // IIFE

</pre>

<h3>Closures - feature of JavaScript</h3>
<p>Every function we running it wiil have access to variables that suppose to have access. </p>
<p>When invoke the function engine look for variables to outer environment - to place of creation.</p>
<p>Its represent value of now not at the time when function is executed.</p>
<p>free variables - still has access to outter variables </p>
 <pre>
function greet(whattosay) {
    return function(name) {
    console.log(whattosay + ' '  + name);
    }
}
greet("Hola")('Milan'); // Hola Milan
// closures
var sayHi = greet('Hi');
sayHi('Tony'); //Hi Tony
</pre>
<pre>
function buildFunctions() {

    var arr = [];

    for (var i = 0; i < 3; i++) {

        arr.push(
            function() {
                console.log(i);
            }
        )

    }

    return arr;
}

var fs = buildFunctions();

fs[0](); // 3
fs[1](); // 3
fs[2](); // 3
</pre>
<pre>
function buildFunctions2() {

    var arr = [];

    for (var i = 0; i < 3; i++) {
        arr.push(
            (function(j) {
                return function() {
                    console.log(j);
                }
            }(i))

        )

    }

    return arr;
}

var fs2 = buildFunctions2();

fs2[0](); // 0

fs2[1](); // 1

fs2[2](); // 2
</pre>

<h3>Function Factory</h3>
<p>Factory  - functions that mix or returns something for us</p>
<p>Every time when we call a function makes new execution context.</p>
<pre>
function makeGreeting(language) {

    return function(firstname, lastname) {

        if (language === 'en') {
            console.log('Hello ' + firstname + ' ' + lastname);
        }

        if (language === 'es') {
            console.log('Hola ' + firstname + ' ' + lastname);
        }

    }

}

var greetEnglish = makeGreeting('en');
var greetSpanish = makeGreeting('es');

greetEnglish('John', 'Doe'); // Hello John Doe
greetSpanish('John', 'Doe'); // Hola John Doe
</pre>
<h3>Closure and Callback</h3>
<p>Callback - Function you give to another function, to be run when the other function is finished.</p>
<pre>
function sayHiLater() {

    var greeting = 'Hi!';

    setTimeout(function() {

        console.log(greeting);

    }, 3000);

}

sayHiLater();

// jQuery uses function expressions and first-class functions!
//$("button").click(function() {
//
//});

function tellMeWhenDone(callback) {

    var a = 1000; // some work
    var b = 2000; // some work

    callback(); // the 'callback', it runs the function I give it!

}

tellMeWhenDone(function() {

    console.log('I am done!');

});

tellMeWhenDone(function() {

    console.log('All done...');

});

</pre>

<H3>This</H3>
<p>Inside function this point to global, window object.</p>
<p>Inside object this point to object, even if function inside object beacuse function inside object is a method..</p>
<p>But this inside fuction who sits inside functio point to global, window.</p>
<p>To avoid problem best way to declare varaible self to point to this object.</p>
<pre>var c = {
  name: 'The c object',
  log: function() {
      var self = this;

      self.name = 'Updated c object';
      console.log(self);

      var setname = function(newname) {
          self.name = newname;
      }
      setname('Updated again! The c object');
      console.log(self);
  }
}

c.log();
</pre>
<h3>Arguments - ES6 Spread</h3>
<p>Arguments contains a list of all values, parameters we passed to function.</p>
<p>keyword arguments - containig a list of all values passed to function</p>
<pre>function greet(firstname, lastname, language) {

     language = language || 'en';

    if (arguments.length === 0) {
        console.log('Missing parameters!');
        console.log('-------------');
        return;
    }
    console.log(firstname);
    console.log(lastname);
    console.log(language);
    console.log(arguments);
    console.log('arg 0: ' + arguments[0]);
    console.log('-------------');
}
greet();
greet('John');
greet('John', 'Doe');
greet('John', 'Doe', 'es');

// in ES6 I can do:  function greet(firstname, ...other)
// and 'other' will be an array that contains the rest of the arguments
</pre>
<h3>call(), apply() and bind()</h3>
<p>All functions have access to this 3 methods.</p>
<p>bind - returns new functions, makes a copy of function and whatever method, object passed by. </p>
<p>call execute functions, not create a copy</p>
<p>apply passed parameters as array</p>

<pre>
var person = {
    firstname: 'John',
    lastname: 'Doe',
    getFullName: function() {

        var fullname = this.firstname + ' ' + this.lastname;
        return fullname;

    }
}

var logName = function(lang1, lang2) {

    console.log('Logged: ' + this.getFullName());
    console.log('Arguments: ' + lang1 + ' ' + lang2);
    console.log('-----------');

}

var logPersonName = logName.bind(person);
logPersonName('en');

logName.call(person, 'en', 'es');
logName.apply(person, ['en', 'es']);

(function(lang1, lang2) {

    console.log('Logged: ' + this.getFullName());
    console.log('Arguments: ' + lang1 + ' ' + lang2);
    console.log('-----------');

}).apply(person, ['es', 'en']);

// function borrowing
var person2 = {
    firstname: 'Jane',
    lastname: 'Doe'
}

console.log(person.getFullName.apply(person2));

// function currying
function multiply(a, b) {
    return a*b;
}

var multipleByTwo = multiply.bind(this, 2);
console.log(multipleByTwo(4));
</pre>
<p>Function Currying - Creating a copy of a function but with some preset parameters.</p>
<h3>Functional programming</h3>
<pre>
function mapForEach(arr, fn) {

    var newArr = [];
    for (var i=0; i < arr.length; i++) {
        newArr.push(
            fn(arr[i])
        )
    };

    return newArr;
}

var arr1 = [1,2,3];
console.log(arr1);


var arr2 = mapForEach(arr1, function(item) {
   return item * 2;
});
console.log(arr2);


var arr3 = mapForEach(arr1, function(item) {
   return item > 2;
});
console.log(arr3);


var checkPastLimit = function(limiter, item) {
    return item > limiter;
}
var arr4 = mapForEach(arr1, checkPastLimit.bind(this, 1));
console.log(arr4);


var checkPastLimitSimplified = function(limiter) {
    return function(limiter, item) {
        return item > limiter;
    }.bind(this, limiter);
};

var arr5 = mapForEach(arr1, checkPastLimitSimplified(1));
console.log(arr5);
</pre>


<h3>Inheritance</h3>
<p>One object gets access to the properties and methods of another object.</p>
<h3>Reflection</h3>
<p>AN object can look at itself, listening and changing its properties and methods.</p>


<h3>Function as Function Constructor</h3>
<p>Function constructors - a normal function that is used to construct object.
  This variable points a new empty object, and that object is returned from the the function automaticaly.</p>
<p>Use <strong>new</strong> as function constructor.</p>
<p>Prototype - used only by the new operator.</p>
<p>Always use capitol letter in the name of function if we will use as function constructor.</p>
<p>Properties are in the functions constructors and methods are sitting in prototype.</p>
<p>Method is placeing outside the function to reduce memory space in the case we have a plenty instances of functions.</p>
<p>It will be changed in ECMAScript 6.</p>
<pre>
function Person(firstname, lastname) {
    this.firstname = firstname;
    this.lastname = lastname;
}
var john = new Person("John", "Doe");
var jane = new Person("Jane", "Doe");

console.log(jane.firstname + ' ' + jane.lastname);

Person.prototype.getformalname = function() {
    return this.lastname + ', ' + this.firstname;
}
console.log(john.getformalname());
 </pre>
<h3>Pure Prototypal Inheritance - Object.create</h3>
<pre>
// polyfill ////////
if (!Object.create) {
  Object.create = function (o) {
    if (arguments.length > 1) {
      throw new Error('Object.create implementation'
      + ' only accepts the first parameter.');
    }
    function F() {}
    F.prototype = o;
    return new F();
  };
}
/////////////////
var person = {
    firstname: 'Default',
    lastname: 'Default',
    greet: function() {
        return 'Hi ' + this.firstname;
    }
}

var john = Object.create(person);
john.firstname = 'John';
john.lastname = 'Doe';
console.log(john);
</pre>

<h3>Variables by Value and by Reference</h3>
<p>By Value</p>
<pre>a = primitive value
b = a
b = copy of primitive value
b have new address
2 separets spots in memory</pre>
<pre>var a =3;
b = a;
a = 2;
console.log(a); // 2

console.log(b); // 3</pre>
<p>By Reference</p>
<pre>When set up variable equal to object
b = a
or
pass to a function
simple point to the same location in a memory like a, 2 name to the same address</pre>
<p>All objects interact by reference when sending them equals to each other or passing to a function</p>
<pre>var c = { greetings: 'hi' };
var d;
d = c;
c.greeting = 'Hello';
console.log(c); // Hello

console.log(d); // Hello


// even as parameters

function changeGreeting (obj) {
  obj.greeting = 'Hola';
}
console.log(c); // Hola

console.log(d); // Hola


// equals operator sets up new memory space (new address)

c = { greeting: 'Howdy'}; // new objects

console.log(c); // Howdy

console.log(d); // Hola
</pre>

<h3>Arrays - Collections of Anything</h3>
<p>Each individual item in array can be differnet type.</p>
<pre>var arr = [
    1,
    false,
    {
      name: "Milan",
      addres: "VPD 11"
    },
    fuction(name) {
      var greeting = "Hello ";
      console.log(greeting + name);
    },
    "Hello"
  ];
  //run a fuction with name parameter
  arr[3](arr[2].name);</pre>
  <h3>Method Chaining - Calling one method after another, and each method affects the parent object.</h3>
  <pre>var q = $("ul.people").addClass("newclass").removeClass("people");</pre>
<h3>Dont use "for in" un arrays.</h3>
<h3>Polyfill - code that adds a feature which the engine may lack. </h3>
<h3>Syntactic sugar - a different way to type something that doesnt change how it works under the hood.</h3>
<h3>Syntax Parsers</h3>
<p>Read our code and determines what is valid and what we trying to do, character by charcter.</p>
<h4>Automatic Semicolon Insertion</h4>
<p>JS engine put semicolon where is missing.</p>
<p>Always put curly bracket at same line as function, foor loop, if statement.</p>
<h3>Whitespace - carriage returns, tabs, spaces.</h3>
<p>Syntax parser just ignore white spaces</p>
<p>JS is very liberal about whitespace.</p>
<h3>JSON</h3>
<p>Convert JSON to java script objec</p>
<pre>JSON.parse('{"firstname": "Milan", "lastname": "Vukovic"}');</pre>
<p>Convert java script to JSON</p>
<pre>var objectLiteral = {
  firstname: "Milan",
  lastname: "Vukovic"
}
JSON.stringify(objectLiteral);
</pre>


  <h3>Dimensions</h3>
  <p>Get width, height, padding, margin, border, window size, viewport and scroll height.</p>
  <pre id="dimensions" onclick="dim()">$(document).ready(function(){
    var pattern = prompt("Enter ellement", "for classes=.class  for id=#div or for tag=a");
    if (pattern != null) {
        var txt = "";
        txt += "Width: " + $(pattern).width() + "\n";
        txt += "Height: " + $(pattern).height() + "\n";
        txt += "Padding(left+right): " + ($(pattern).innerWidth()-$(pattern).width()) + "\n";
        txt += "Padding(up+down): " + ($(pattern).innerHeight()-$(pattern).height()) + "\n";
        txt += "Border: " + ($(pattern).outerWidth()-$(pattern).innerWidth())/2 + "\n";
        txt += "Margin(left+right): " + ($(pattern).outerWidth(true)-$(pattern).outerWidth()) + "\n";
        txt += "Margin(up+down): " + ($(pattern).outerHeight(true)-$(pattern).outerHeight()) + "\n";
        txt += "Windows size: " + $(document).width();
        txt += "x" + $(document).height() + "\n";
        txt += "Viewport size: " + $(window).width();
        txt += "x" + $(window).height() + "\n";
        txt += "Scroll height" + window.pageYOffset ;
        alert(txt);
    }
});
</pre>

<br>
    <div class="footer-tuts">
    | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">Reference</a>
    | <a href="https://github.com/lukehoban/es6features">ECMA6 Features</a>
    | <a href="https://www.youtube.com/watch?v=Bv_5Zv5c-Ts" target="_blank"><img class="icons" src="../images/youtube.png" alt="youtube" /></a>
    | <a href="http://underscorejs.org/">Underscore.js</a>
    | <a href="http://momentjs.com/">Moment.js</a> |

  </div>

</div>
  </body>
  <script src="../js/scroll.js"></script>
</html>
